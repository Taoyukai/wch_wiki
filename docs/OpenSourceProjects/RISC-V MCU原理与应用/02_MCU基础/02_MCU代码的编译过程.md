---
sidebar_position: 2
description: 介绍开发MCU时，高级语言最终转换成MCU识别的机器语言的过程。并介绍elf、hex、bin三种MCU目标文件格式。
---

# MCU代码的编译过程

## 1. 编程语言的进化

### 1.1 机器语言

通过前面的介绍，我们了解到MCU只能够识别的只有0和1这样的指令，具体的指令格式都是由RISC-V等指令集架构规定的。

而在早期的编程都是通过纸带打孔的方式表示0和1指令的指令序列，实现所需程序。

这就是最原始的**机器语言编程**。

| ![punch_paper_0](img\punch_paper_0.jpg) | ![punch_paper_1](img\punch_paper_1.jpg) |
| --------------------------------------- | --------------------------------------- |

### 1.2 汇编语言

![binary_code](img\binary_code.png)

上面这段机器语言的代码，可读性非常差，后期不易维护。

为了解决这一问题，聪明的人类给机器语言加上了助记符，这样就有了汇编语言。

如在RISC-V中，需要将x5和x6寄存器中的值相加保存在x7寄存器中，代码如下：

- 机器语言：00000000010100110000001110110011 
- 汇编语言：add x7, x5, x6



### 1.3 高级语言

虽然汇编语言采用了英文缩写的标识符，更容易识别和记忆，但是汇编语言本质上和机器语言相同，都是直接对硬件操作，对开发人员并不友好，开发效率并不高。

所以，高级语言就此诞生啦，如C/C++，JAVA，Python等，程序猿的队伍也愈发壮大。



## 2. 编译过程

C语言编写程序开发MCU是常用的一种方式，但C语言这样的高级语言并不能像机器语言那样直接在MCU中运行，需要进行转换后才能被执行，这样的过程称之为**编译**。

编译主要分为以下四个过程：

- 预处理（cpp）
- 编译（ccl）
- 汇编（as）
- 链接（ld）

![bulid_1](img\bulid_1.png)

### 2.1 预处理（Pre-Processing）

主要包括宏定义（#define），文件包含（#include），条件编译(#ifdef)三部分。

预处理期间将检查包含预处理指令的语句和宏定义，并对其进行响应和替换，并删除程序中的注释和多余空白字符，最后会生成 **.i 文件**。

### 2.2 编译（Compiling）

编译器会将预处理完的 .i 文件进行一些列的语法分析，并优化后生成对应的汇编代码，生成 **.s 文件**。

RISC-V  MCU的工程采用**GCC**编译，官方工具链地址：https://github.com/riscv/riscv-gnu-toolchain。

当然，各厂家会根据自家的内核设计，修改对应的工具链以支持其特色功能，如沁恒微电子的RISC-V MCU所特有的HPE硬件压栈和VTF免表中断技术，需要在中断服务函数增加指令 `__attribute__((interrupt("WCH-Interrupt-fast")))`，然后在编译时会识别并省略软件压栈的过程。

### 2.3 汇编（Assembling）

通过汇编器将编译器生成的 .s 汇编程序汇编为机器语言或指令，也就是机器可以执行的二进制程序，生成 **.o 文件**。

### 2.4 链接（Linking）

根据**“\*.ld”**链接文件将多个目标文件**(.o)**和库文件**(.a)**等输入文件链接成一个可执行输出文件**(.elf)**。

涉及到对**空间和地址的分配**以及**符号解析与重定位**。

## 3. elf、hex、bin文件说明

编译最终生成的可执行文件为elf、hex或bin文件，这些文件之间的联系如下：

### 3.1 elf文件

**ELF**(**E**xecutable and **L**inkable **F**ormat)，可执行与可链接格式。

> elf是一种用于二进制文件、可执行文件、目标代码、共享库和核心转储格式文件。是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。

ELF文件记录的信息更多、更复杂。主要包含以下内容：

- ELF头(ELF header) - 描述文件的主要特性：类型，CPU架构，入口地址，现有部分的大小和偏移等等；
- 程序头表(Program header table) - 列举了所有有效的段(segments)和他们的属性。 程序头表需要加载器将文件中的节加载到虚拟内存段中；
- 节头表(Section header table) - 包含对节(sections)的描述。

![elf](img\elf.png)

### 3.2 hex文件

HEX格式文件由Intel制定的一种十六进制标准文件格式，一种**ASCII**文本文件。文件的每一行都包含了 一个HEX记录。这些记录是由一些代表机器语言代码和常量的16进制数据组成的。Intel HEX文件常用来传输要存储在ROM 或者 EPROM中的程序和数据。大部分的EPROM编程器和FLASH能使用Intel HEX文件。

格式如下：

| 行开始 | 数据长度 | 地址  | 数据类型 | 数据  | 校验  |
| ------ | -------- | ----- | -------- | ----- | ----- |
| ：     | BB       | AAAA  | TT       | D……D  | CC    |
|        | 1字节    | 2字节 | 1字节    | n字节 | 1字节 |

- ：冒号，代表行开始
- BB代表Bytes，数据长度
- AAAA代码Address，表示数据这行数据的存储地址
- TT代表Type，数据类型(标识)
    - 00：数据标识
    - 01：文件结束标识
    - 02：扩展段地址
    - 03：开始段地址
    - 04：线性地址
    - 05：线性开始地址
- D……D代表Data，有效数据
- CC代表CheckSum，校验和

### 3.3 bin文件

bin是binary的缩写，即二进制文件，全是0或1的文件，最底层的可执行的机器码。

bin文件只包含程序数据。

bin文件的大小直接反应所占flash内存的大小。

### 3.4 转换关系

因为bin、hex都是只是记录数据的，但elf类型不仅记录数据还有程序描述，所以elf文件通过gcc中的objcopy可转换成hex或bin文件，hex文件也可转换成bin文件，但反之不可。

### 3.5 总结

bin文件最小最简单，但是安全性差，功能性差，hex包含头尾和检验，就有很好的安全性，但是文件比bin大，功能没有elf强大；elf功能多，但是文件最大。

在使用工程编译结果是，最好有bin或者hex同时具有elf文件，elf用于仿真和调试，但输出的到工厂的文件可以使用hex和bin。

## 4. 编译后程序占用的内存分配

（1）**文本段（.text）**：或称代码段，通常是用来存放程序执行代码的一块内存区域。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

（2）**数据段（.data）**：通常是用来存放程序中已初始化的全局变量的一块内存区域。一般常量字符串就是放在这里的，程序结束后由系统释放。只读数据段(只读常量区) 和数据段（全局变量区）统称为 数据段。

（3）**.bss段**：未初始化的全局变量和static修饰的局部变量（**初始化默认值为0**）；



:::tip

推荐阅读《程序员的自我修养》这本书，详细了解一个应用程序在编译、链接和运行时刻所发生的各种事项。

:::



